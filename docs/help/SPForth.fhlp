( Справка по особенностям SP-FORTH от стандарта  )
( А также русские эквиваленты стандартных слов   )


*** {{
 ( "name" -- )

 Взять из входного потока и выполнить "name".
 Если это VOCABULARY сделать содержащийся в нем
 wordlist первым в порядке поиска.
 Если это слово, возвращающее wordlist на стеке данных,
 сделать данный wordlist первым в порядке поиска.

 file:  compiler\spf_modules.f
 forth:  спф 4.0 и выше

 IMMEDIATE слово.

*** }}
 ( -- )
 : }} PREVIOUS ; IMMEDIATE

***

FORTH - Язык среднего уровня и интерактивная среда разработки.
Нашел широкое применение в науке, робототехнике, управлении
оборудованием, обработке образов и искусственном интеллекте.
Позволяет создавать очень компактные и быстрые программы.

Попробуйте набрать HELP HELP
а также TOPIC и HELP TOPIC

*** HELP
  ( "name" -- )
  Подключает файл help.fhlp, ищется и печатается справочная
  документация к слову "name".
  ( -- )
  Общие сведения о форте.

  Поиск происходит по умолчанию в файлах
  docs\ANSFth94.fhlp
  docs\SPForth.fhlp

  Если ничего не найдено, слово преобразуется в верхний
  регистр и ищется снова. Так что можно писать help help.
  Но, скорость поиска при это замедляется в 2 раза! Поэтому
  целесообразно писать слово так, как оно выглядит.
  Синтаксис help help для ленивых людей с мощными компьютерами (it's me :)
  Вы можете создавать и подключать справку к своим
  собственным библиотекам.

  file: lib\ext\help.f
  forth: спф 4.0 и выше

*** EXTRA-MEM

   ( -- addr )

   VARIABLE переменная, изначально содержит 16384.
   При создании хипа функцией CREATE-HEAP общий размер
   хипа равен: USER-OFFS + EXTRA-MEM + 4
   Возможно перед сохранением записать в EXTRA-MEM 0.
   Эта переменная нужна как буфер для USER переменных, которые
   возможно будут работать на этапе подключения форт текста.

   file: win\spf_win_memory.f
   forth: спф 4.0 и выше

*** USER
  ( "name" -- )

  Создает переменную аналогично VARIABLE, но эта переменная создается
  динамически при запуске форт системы и инициализируется нулем.
  Сделано для поддержки многопоточности ядром. У кажого потока свои
  копии USER переменных.
  В сп-форте для каждого потока создается
  _отдельный_ хип (и именно из него выделяется блок для USER vars).
  И ALLOCATE выделяет память из локального хипа потока. Соответственно
  автоматически освобождается при завершении потока (если этот поток
  завершается сам, а не убивается другим потоком по STOP).

  file: compiler\spf_defwords.f
  forth: спф 3.75 и выше

*** USER-OFFS
   ( -- addr )

   VARIABLE переменная, содержит текущее смещение в области данных потока, 
   где создаются USER переменные.

   file: win\spf_win_memory.f
   forth: спф 3.75 и выше

*** IF

IF...ELSE...THEN
Условие IF...ELSE...THEN.

( flag --> )
Параметры
flag
если flag <> 0 , то выполнить все слова, которые нахдятся в промежетке
IF ...THEN, кроме слов в промежутке ELSE ...THEN (если слово ELSE вообще
используется в условии).

если flag = 0, то пропустить все слова в диапозоне IF...THEN и выполнить
первое слово после слова THEN, если внутри ветви находится слово ELSE
(IF...ELSE...THEN), то выполнить все слова в промежутке ELSE...THEN.
Заметки
IF...ELSE...THEN

Рассмотрим пример слова /, которое берёт со стека два числа и делит
первое на второе и выводит на экран результат деления, но если
делитель =0 (что соответственно противоречит законам математики),
то слово выводит на экран сообщение "Ошибка деления..." и выводит
на экран результат деления = 0.

: / ( x1 x2 --> )
  DUP       \ дублирую делитель   ( x1 x2 x2 )
  0=        \ сравниваю его с 0   ( x1 x2 flag )
  IF        \ если делитель = 0
     2DROP  \ , то удаляю со стека 2 числа
     0      \ осталяю на вершине стека 0
     ." Ошибка деления..."   \ вывожу сообщение об ошибке
            \ пропускаю слова в промежутке ELSE ... THEN и перехожу к слову .
  ELSE      \ иначе, если делитель не равен 0
     /      \ , то выполняю деление и на стеке остаётся результат деления
  THEN
     ." результат=" .  \ вывожу сообщение "результат=" и частное от деления
;

Условие может содержать альтернативную ветвь ELSE, но можно пользоваться
и без неё, если нужно обработать только одно условие.


Например:


: ЖАРКО? ( t --> )
\ слово выводит предупреждение на консоль если температура t превысит 80 С.
   80 >     ( flag )
   IF    \ если температура превышает 80 C
    ." ОПАСНО ! Уменьшите нагрев!"   \ вывести предупреждение на экран
   THEN
;

Имеется возможность помещать оператор IF...THEN (или IF ... ELSE ... THEN)
внутрь другого оператора IF...THEN. Фактически можно использовать
неограниченную вложенность условий друг в друга.

Все условия являются совокупностью вложенных IF...THEN. Они вложены друг
в друга, как матрёшки. Три слова IF соответстуют трём словам THEN.

  IF----------------|
  IF---------|      |
  IF--|      |      |
     THEN   THEN   THEN

ПОМНИТЕ ! Что каждому слову IF должно соответствовать своё THEN, причём
в пределах одного и того же определения.

Например:


  IF
   ...
     IF
      ...
        IF
          ...
        THEN
     THEN
  THEN

Основненое применение условий - проверка значений, которые оставляют
операции сравнения =, <>, <, >, 0= и т.д.

*** +LOOP
*** ?DO
*** DO
*** LOOP
*** (+LOOP)
*** (?DO)
*** (DO)
*** (LOOP)
*** UNLOOP

Цикл со счетчиком вида
>
> ВерхняяГраница НачальноеЗначение DO ... LOOP
реализуется с помощью кода вида
$ (DO) [ссылка_на_Адрес2]  ....  (LOOP)
$     ^                                ^
$     |                                |
$     Адрес1                           Адрес2

использует стек возвратов для хранения вспомогательной информации.

На стеке возвратов (специфично для спф систем) -
$   Адрес1
$   ВерхняяГраница+0x80000000
$   НачальноеЗначение-(ВерхняяГраница+0x80000000)
$   (--вершина стека--)

*** ,"
&unstandard ," "запятая-кавычка" Compat

 ," ( "ccc<">" -- )

Выбрать из входного потока строку, ограниченную кавычкой, и уложить ее в шитый
код в формате строки со счетчиком. Выравнять указатель словаря на границу
токена функции (требования те же, что и для ячейки).

*** OK
Печатает "подсказку": текст "ok" и верхние элементы стека. Вызывается
интерпретатором при интерпретации текста с консоли.

Векторное слово, по умолчанию вызывается OK1.

***g: RunTime
*** ?BRANCH
&unstandard ?BRANCH "вопрос-бранч" Compat

 ( true -- ) ( I: ip[codeAddr] -- ip+ )
 ( false -- ) ( I: ip[codeAddr] -- codeAddr )

 Код: ?BRANCH [ссылкаНаКод]

 Если на стеке ненулевое значение, ссылка, находящаеся за словом ?BRANCH,
 пропускается. Если на стеке нулевое значение, выполняется переход.
 Используется для реализации операторов
> IF
и
> WHILE

*** SEE
  file: lib\ext\disasm.f
  forth: spf3.16 и выше

*** MODULE:
   ( "name" -- )

  start a forth module
  Если такой модуль уже существует, продолжить компиляцию в него.
  Если нет, создать. Установить первый wordlist поиска wordlist
  модуля. А также установить CURRENT. см. DEFINITIONS.
  В настоящее время частным случаем модуля является VOCABULARY.

  см. также: EXPORT ;MODULE

  file: compiler\spf_modules.f
  forth: спф 4.0 и выше

*** EXPORT
   ( wid -- wid )

   Начать компиляцию во внешний словарь по отношению
   к данному модулю. Обязательно использовать только в пределах
   модуля.

   file: compiler\spf_modules.f
   forth: спф 4.0 и выше

   см. также: MODULE: ;MODULE

*** ;MODULE
   ( wid -- )
   Закончить определение модуля, снять верхний wordlist поиска,
   установить CURRENT в wid (это CURRENT перед компиляцией модуля)


*** MODULE:
*** EXPORT
*** ;MODULE
  пример использования:

MODULE: xxx
...
;MODULE

======= или

MODULE: xxx
...
EXPORT
...  \ Эти слова будут компилироваться во внешний по
     \ отношению к данному модулю
;MODULE

====== или
VOCABULARY xxx \ так можно, потому что VOCABULARY это частный (!)
               \ случай модуля

: test xxx PROCESS-IN-XXX ;

MODULE: xxx \ здесь в уже созданный ххх будет компилить...
...
;MODULE

====== или

MODULE: xxx
...
EXPORT
...
DEFINITIONS
...
EXPORT
...
DEFINITIONS
...
;MODULE

*** ~ruvim
   Ruvim Pinka          ruvim@forth.org.ru
*** ~boa
   Bordachev Andrej     glareboa@mail.ru
*** ~day
   Dmitry Yakimov       ftech@tula.net
*** ~micro
   Dmitry Zyryanov      micro@forth.org.ru
*** ~1001
   Konstantin Tarasov   const@penza.com.ru
*** ~ac
   Andrey Cherezov      andrey@cherezov.koenig.su
*** ~nemnick
   Nicholas Nemtsev     nn@vdk.psc.ru
*** ~mak
   Michael Maximov      mak@mail.rtc.neva.ru
*** ~yz
   Yuriy Zhilovets      yz@nightmail.ru
*** ~mlg
   Michael Gassanenko   mlg@forth.org
*** ~oleg_sh
   Oleg Shalyopa
*** ~trasher
   Dmitry Bobrik


*** AT-THREAD-STARTING
*** AT-PROCESS-STARTING
*** AT-THREAD-FINISHING
*** AT-PROCESS-FINISHING

  Слова, созданные по технологии Scattered Colon Definition by
  (см. ~mlg).
  Использование:
  Например - необходимо чтобы каждый раз при запуске форт системы
  печаталась цифра 2:

  ..: AT-PROCESS-STARTING 2 . ;..
  если еще раз:
  ..: AT-PROCESS-STARTING 2 . ;..
  то будет печататься уже две двойки.

  ..: и ;.. - специальные слова форт системы.

*** spf.ini
   Файл, который подключается при запуске форт системы словом
   SPF-INI. Подключается простым INCLUDE-PROBE

*** spf.log
   Лог файл форт системы. См. слова STARTLOG ENDLOG TO-LOG H-STDLOG

*** <EOF>
   ( -- )
   Прекращает трансляцию текущего файла. Аналог
   SOURCE-ID FILE-SIZE THROW SOURCE-ID REPOSITION-FILE ...
   только более короткий.

   file: compiler\spf_translate.f
   forth: spf 4.0 и выше

*** TIMER@
    ( -- tlo thi )

  Возвращает значение таймера процессора (команда RTDSC)
  (только для процессоров Intel Pentium совместимых).
  Число тактов процессора за прошедшее время.
  Возвращаемое значение зависит от частоты процессора.

  file: spf_forthproc.f
  forth: spf 4.0 и выше

*** NOTFOUND
  ( addr u -- i*x )
  
  Если INTERPRET не находит слово в контексте поиска, оно
  ищет NOTFOUND в текущем контексте поиска и
  вызывает NOTFOUND с этим словом как параметром.
  Может быть определено как:

  : NOTFOUND ?SLITERAL ;

  Но также еще поддерживается синтаксис:
  <vocabulary>::<word>

  Слово NOTFOUND может делать с литералом что угодно (вместо SLITERAL?)
  Например:
  5 5 + .
  10  Ok
  : NOTFOUND ." =" TYPE ." = " ;
   Ok
  5 5
  =5= =5=  Ok

  см. также ::

  file: compiler\spf_translate.f
  forth: spf 4.0 и выше

*** ::

  Синтаксис доступа к словам в словарях.
  <vocabulary>::<word>
  Или
  <vocabulary1>::<vocabulary1>::<vocabulary1>::<word>

  Поддерживаются как режим компиляции, так и интерпретации.
  Причем все слова кроме последнего после :: исполняются (!)
  вне зависимости от состояния STATE.
  Перед <word> может быть пробел, например: <vocabulary>:: <word>
  Это для ситуаций типа:
     : DO-SMTH::  PROCESS-SMTH S" Voc1::" EVALUATE-WITH ;

     DO-SMTH:: SOME-WORD

  file: compiler\spf_translate.f
  forth: spf 4.0 и выше

  см. EVALUATE-WITH

*** EVALUATE-WITH
   ( i*x c-addr u xt -- j*x )

   Считая c-addr u входным потоком, вычислить её интерпретатором xt.
   Например:

   : SVARIABLE ( addr u )
       ['] VARIABLE EVALUATE-WITH
   ;

  см. также: EVAL-WORD EVALUATE

  file: compiler\spf_translate.f
  forth: spf 4.0 и выше

*** EVAL-WORD
   ( c-addr u -- )

   Интерпретировать ( транслировать) слово с именем  c-addr u

  см. также: EVALUATE-WITH EVALUATE

  file: compiler\spf_translate.f
  forth: spf 4.0 и выше

*** TERMINATE
   ( -- )

   Уничтожить текущий поток и его хип.

  file: win\spf_win_mtask.f
  forth: spf 4.0 и выше

*** TOPIC
   ( -- )
   Отображение содержания справки
   ( "name" -- )
   Отображения содержимого "name" пункта содержания (это может
   быть список слов на данную тему например).