<?xml version="1.0" encoding="Windows-1251"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>
<book><!--  xml:space="preserve" -->

<!-- 2007 ruvim@forth.org.ru -->
<!-- $Id$ -->

<h2>Именования</h2>

<toc/>

<chapter id="question-mark"><title>Ведущий знак вопроса</title>
<p>Ведущий знак вопроса в имени обозначает 
условное исполнение действия (<small>“operates conditionally”, Thinking Forth, L. Brodie</small>).
Классический пример — слово <w ds="x -- x x | 0">?DUP</w>.
Означает «может быть <w>DUP</w>» (“may be <w>DUP</w>”), здесь условность
отражется и на стековом эффекте.
Еще пример, слово <w>?DO</w> — выполняет функцию <w>DO</w> если граничные значения различны.</p>
<p>Общее свойство: <i>есть родственное слово с безусловным поведением</i>.</p>
<p>По аналогии названы слова: 
<w>?FOREACH-LIST</w> (работает как <w>FOREACH-LIST</w>, но прекращает по флагу FALSE),
<w>?EXIT</w> (выполняет <w>EXIT</w> если дано TRUE).
</p>

<p>Слова <w>?STACK</w> и <w>?CSP</w> тоже имеют условное поведение,
но не имеют родственных слов (безусловного варианта действия) 
в силу недостаточной факторизации.</p>

<p>Использование же ведущего знака вопроса для слов, 
просто возвращающих флаг, являетя моветоном.
</p>
</chapter>

<chapter id="flag"><title>Слова, возвращающие флаг</title>
<p>Пример: <w ds=" c -- flag ">IS-WHITE</w> — слово анализирует
аргумент на стеке. Используется префикс <w>IS-</w>, 
общий вид: <w>IS-[SOMETHING]</w> (или, <w>Is[Something]</w>).
</p>
<p>Пример: <w ds=" -- flag ">STATE?</w> — слово дает флаг
по состоянию связанного или заданного косвенным образом объекта.
Знак вопроса выступает <i>суффиксом</i>. Обычно, есть родственные слова
с тем же корнем.
</p>
<p>Одновременное использование и префикса “<w>IS</w>” и суффикса
“<w>?</w>” излишне.</p>
<p><b>Замечание.</b> В некоторых форт-системах есть слово <w>IS</w>,
которое работает как слово <w>TO</w> и по смыслу служит для установки значения
(утверждение), а не для получения (вопрос).</p>
</chapter>

<chapter id="capital"><title>Прописные и строчные</title><!-- upper-case, lower-case -->

<p>В имена вкладывается (мной вкладывается :) дополнительная информация 
на основе вида составляющих их букв.
Возможные варианты: все <w>ПРОПИСНЫЕ</w>, <w>Смешанный</w>, все <w>строчные</w>.
В таком же порядке код идет от низкоуровневого (прописные) к высокоуровневому (строчные).
В качестве бонуса, это еще и согласуется с другим значением слова «прописной» — «обыкновенный».
</p>

<p>Неправильный код должен выглядить неправильно.
У Джоэля Спольски есть хорошая <a href="http://local.joelonsoftware.com/mediawiki/index.php/%D0%9A%D0%B0%D0%BA_%D0%B7%D0%B0%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C_%D0%BD%D0%B5%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4_%D0%B2%D1%8B%D0%B3%D0%BB%D1%8F%D0%B4%D0%B5%D1%82%D1%8C_%D0%BD%D0%B5%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE">статья</a>
на эту тему:
<a href="http://www.joelonsoftware.com/articles/Wrong.html">Making Wrong Code Look Wrong</a>.
Использование регистра букв тоже помогает в этом.
Для проверки стиля используются следующии критерии:
<ul>
<li>в определении прописных слов используются только прописные слова;</li>
<li>в высокоуровневом коде не должно быть прописных слов (кроме, быть может, 
структур управления классического форта).</li>
</ul>
</p>

<p><b>Замечание.</b> Использовать везде только один регистр —
это лишать исходный код одного из каналов информации, это как убрать одну из составляющих RGB-палитры.
А каналов этих и так мало.
</p>

</chapter>

<chapter id="systematics"><title>Нарушение систематики</title>
<p>Пример того, как делать не надо, это следующие пары стандартных слов:
<ul>
<li><w ds=" n -- n*size1 ">CELLS</w> и <w ds=" -- size1 ">CELL</w>,</li> 
<li><w ds=" n -- n*size2 ">CHARS</w> и <w ds=" 'ccc' -- c ">CHAR</w>.</li>
</ul>
</p>
<p><i>Слова с подобными именами должны иметь подобную сигнатуру.</i>
Здесь слово <w>CHAR</w> нарушает этот принцип.</p>

<p>Аналогичный пример из библиотеки <a href="../../../../~ac/lib/str5.f">str.f</a>:</p>
<ul>
<li><w ds=" addr u s -- ">STR+</w> и <w ds=" addr u s -- ">STR!</w>,</li> 
<li><w ds=" s1 s2 -- ">S+</w> и <w ds=" addr u var_addr -- ">S!</w>.</li>
</ul>

</chapter>

<chapter id="pieces"><title>Мера грануляции</title>
<p>Мера разбиения фрагментов кода по словам
определяется удобством <i>повторного использования</i> (в него входит и модификация).
Точно так же определяется и мера разбиения кода <i>по файлам</i>.
</p>
<p>Именно поэтому ядро модуля выделяется в один файл,
а обертка и привязка к системе — в другой файл, — чтобы была
возможность использовать ядро с другой оберткой.
Неудачная грануляция ведет к 
<a href="../../2004/spf/FStream/readme.txt">дублированию кода</a>,
когда нужно «точно такой же, только с перламутровыми пуговицами».
</p>

</chapter>

<chapter id="what"><title>Заимствования имен</title>
<p>При реализации известных интерфейсов
используются их устоявшиеся лексиконы, нет нужды придумывать новые.
Например, при <a href="../../../lib/lin/xml/libxml2-dom.f">реализации</a> DOM-интерфейса был взят напрямую и его же лексикон,
закрепленный в <a href="http://www.w3.org/TR/DOM-Level-2-Core/def-index.html">спецификации</a>
w3c (при разработке этих стандартов народ
<a href="http://lists.w3.org/Archives/Public/public-webapi/2007Jun/0077.html">кучи копий ломает</a>
в поисках лучших имен ;).
Слова для <a href="../../../model/lib/string/match.f.xml">работы со строками</a>:
<w>STARTS-WITH</w>, <w>ENDS-WITH</w>, <w>SUBSTRING-AFTER</w>, <w>SUBSTRING-BEFORE</w>,
<w>CONTAINS</w> — и действуют и называются по
соответствующему лексикону XSLT.
</p>

</chapter>

<chapter id="links"><title>Ссылки по теме</title>
<p><ul>
<li><a href="http://my.opera.com/forth/blog/ethymology">Этимология (проФорт)</a></li>
<li><a href="http://www.nabble.com/Iterator-t4336038.html">Именования итераторов (spf-dev)</a></li>
</ul></p>
</chapter>

</book>
