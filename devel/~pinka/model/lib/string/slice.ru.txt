\ Mar.2008

—лово "HEAD|TAIL" ( a u -- a-head u-head  a-tail u-tail ) 
  разбивает строку на две подстроки: голову из одного символа (который слева)
  и хвост из всех оставшихс€ символов.

  »м€ мимикрирует под сопоставление с образцом (pattern matching)
  в ѕрологе: [H|T]  (оно там дл€ списков и дл€ строк, которые тоже списки).

  », в то же врем€, оно дает индикацию пор€дка выходных значений!


јналогичное им€ и у слова "WORD|TAIL" ( a u -- a-word u-word  a-tail u-tail )
  -- оно разбивает строку на первое слово (пропустив ведущие пробелы) и остаток.


 аждое из этих слов образует (теоретически) семейство схожих слов,
  которые дают результат в другом пор€дке или идут от конца строки.


—лово SPLIT ( ... -- a-left u-left  a-right u-right ) 
  разбивает строку на две части, дава€ тот же естественный 
  пор€док на выходе: `ab+cd `+ SPLIT --> `ab `cd
  Ќо, часто бывает удобно иметь обратный пор€док на выходе.
  ƒл€ этого слова выбрано им€ "SPLIT-" ( ... -- a-right u-right  a-left u-left ) 
  -- с дефисом в конце дл€ индикации другого пор€дка на стеке. 
  Ёто правило "дефиса в конце" нашло применение и во многих других словах,
  дл€ образовани€ семейств имен.


≈сли же посмотреть на "HEAD|TAIL", то, исход€ из него,
что должно делать слово с именем "TAIL|HEAD"? ј что "HEAD|TAIL-"?

  “ут возникает конфликт.  акой посыл сильней: индикаци€ пор€дка на выходе
  или индикаци€ "перевернутого" образца (т.е. считать у строки голову справа *).


  Ќа данный более убедительным найдены варианты 
    "HEAD|TAIL-" -- дает обратый пор€док на выходе,
    "TAIL|HEAD"  -- считает, что голова справа.


  * ¬ случае обычного сопоставлени€ с образцом, TAIL и HEAD были бы всего лишь
  названи€ми переменных, которые могут быть любыми. Ќапример [X|Y]. «начение 
  переменной определ€етс€ ее местом в образце, название роли не играет. Ќо здесь
  названи€ играют роль т.к. составл€ют единый символ лишь с намеком на образец.

