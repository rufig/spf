<?xml version="1.0" encoding="windows-1251" ?>
<forth xmlns="http://forth.org.ru/ForthML/">
<!-- 2007 -->
<comment>See also: http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern</comment>

<!-- require list-plain.f.xml -->

<cell name="chain-current"/>
<cell name="chain-context"/>

<cell name="chain-context-node"/>
<cell name="chain-tree-stack"/>

<def name="advice-before" ds=" xt -- ">
  0 , HERE SWAP , chain-current @ BIND-NODE
</def>
<def name="advice-after" ds=" xt -- ">
  0 , HERE SWAP , chain-current @ BIND-NODE-TAIL
</def>

<def name="perform-node-cond" ds=" i*x node -- j*x flag ">
<rem> see also: list-plain.f.xml/PERFORM-NODE-COND </rem>
  chain-tree-stack   @ >R
  chain-context-node @ >R
  RP@ chain-tree-stack !
  <repeat> DUP <while/> DUP chain-context-node ! @ EXECUTE  DUP 0EQ <while/> 
    DROP chain-context-node @ CELL- @
  </repeat><!-- ( true|false ) -->
  R> chain-context-node !
  R> chain-tree-stack   !
</def>
<def name="perform-chain-explicit" ds=" i*x h -- j*x flag ">
  @ perform-node-cond
</def>
<comment>
  ÷епочки могут неформально сцепл€тс€ через perform-chain-explicit в обработчике,
  что ведет к образованию дерева узлов. ќпераци€ perform-chain-next должна
  отработать все оставшиес€ узлы в пор€дке обхода дерева, а не только
  текущую цепочку. ƒл€ реализации такого обхода, все точки ветвлени€
  сохран€ютс€ в список, размещаемый на стеке возвратов. ячейка
  chain-tree-stack ведет на голову этого списка. ѕри вложенном поиске
  следующего узла этот список рекурсивно разматываетс€, а после завершени€
  операции возвращаетс€ на место. –азматывать его необходимо дл€
  избегани€ бесконечной косвенной рекурсии.

  “еоретически, така€ операци€ неплохо ложитс€ на BacFORTH, но, насколько € понимаю,
  в этом случае использование стека возвратов будет пропорционально общему числу 
  узлов в дереве. ј в данном решение оно пропорционально числу ветвлений.
</comment>
<def name="perform-chain-next" ds=" i*x -- j*x flag ">
  chain-context-node @ CDR DUP <unless><exit/></unless>
  perform-node-cond DUP <if><exit/></if> DROP
  chain-tree-stack @ 2@ DUP <unless><rem> context-node is null </rem> NIP <exit/></unless>
  chain-tree-stack   @ >R
  chain-context-node @ >R
  chain-context-node !
  chain-tree-stack   !
  <recurse/>
  R> chain-context-node !
  R> chain-tree-stack   !
</def>
<def name="perform-chain" ds=" i*x -- j*x flag ">
  chain-context @ DUP <unless><exit/></unless>
  perform-chain-explicit
</def>
<def name="perform-chain-sure" ds=" i*x -- j*x ">
  perform-chain <if><exit/></if> ABORT
</def>

</forth>
