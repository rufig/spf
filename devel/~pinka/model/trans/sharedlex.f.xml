<?xml version="1.0" encoding="Windows-1251" ?>
<forth xmlns="http://forth.org.ru/ForthML/">

<!-- Jun.2008 -->
<!-- $Id$ -->

<comment> Sharedlex extension to the spf4/forthml translator </comment>

<include href="chain-t-native.f.xml"/><rem> only once </rem>

<wordlist name="sharedlex-hidden">
  <include href="../data/scope.f.xml"/>

<const name="/scope"> 50 CELLS </const>

  <also wordlist="scope-hidden">

<def name="NEST-SCOPE" ds=" -- ">
  Z0 @ >CS Z9 @ >CS ZP @ >CS
  /scope ALLOCATED OVER >CS ASSUME-SCOPE
</def>
<def name="UNNEST-SCOPE" ds=" -- ">
  CS> FREE THROW
  CS> ZP ! CS> Z9 ! CS> Z0 !
</def>
<def name="SCOPE-DEPTH" ds=" -- n ">
  Z0 @ >CELLS  ZP @ >CELLS - 
</def>

  </also>

<def name="SCOPE-ORDER." ds=" -- ">
  0 <q> SWAP 1+ FALSE </q> SCAN-SCOPE-WITH DROP
  0 >R <repeat> DUP <while/> SWAP >R 1- </repeat> DROP
  <repeat> R> DUP <while/> SPACE SPACE VOC-NAME. CR </repeat> DROP
</def>
<def name="NDROP-SCOPE" ds=" u -- ">
  DUP <unless> DROP <exit/></unless>
  DUP SCOPE-DEPTH UGT <if> -5017 THROW </if>
  <times> DROP-SCOPE </times>
</def>

<cell name="_buf"/><rem> sharedlex order stack </rem>

<export>
<def name="init-sharedlex" ds=" -- ">
  /scope CELLS ALLOCATED  OVER _buf !
  ASSUME-SCOPE
</def>
</export>
<rem>
<handler event="startup">
  init-sharedlex
</handler>
<handler event="shutdown">
  _buf @ FREE-FORCE
  _buf 0!
  0. ASSUME-SCOPE
</handler>
<handler event="recovery">
  _buf 0!
  0 0 ASSUME-SCOPE
</handler>
</rem>

<def name="I-NATIVE-EXT" ds=" c-addr u -- xt true | c-addr u false ">
  <xt-of name="FIND-WORDLIST"/> SCAN-SCOPE-WITH
</def>

<init>
 <xt-of name="I-NATIVE-EXT"/> chain-t-native::advice-before
 <comment>
   Поиск по контексту sharedlex включается в фазу 'I-NATIVE',
   в которой идет итерпретация обычных форт-слов (поиск по
   текущему контексту). Таким образом получается, что распознавание 
   квалифицированных слов (имен, уточненных словарем, типа voc::word)
   автоматически работает и для слов из контекста sharedlex.

   Включение сделано через advice-before — вначале идет поиск
   по sharedlex, а потом по обычном контексту. См. TODO ниже.
 </comment>
</init>

<export>
<def name="SHAREDLEX-ORDER." ds=" -- ">
  <emit>Shared lexicons:</emit> CR SCOPE-ORDER. CR
</def>

  `lexicon.basics-aligned FORTH-WORDLIST @ CDR-BY-NAME NIP NIP
  `FORTH-KERNEL WORDLIST-NAMED !

<def name="SHAREDLEX-TOP" ds=" -- wid">
  SCOPE-TOP 
</def>
</export>

<wordlist name="deployed"><comment>
  Корневой словарь для разделяемых лексиконов;
  содержит уникально именованные словари загруженных лексиконов.

  Располагается в базовом хранилище (точнее, в текущем на момент
  данной трансляции, но, по соглашению оно должно быть и базовым).

  Другой возможный вариант: загружать из дочерних потоков 
  в другое (не базовое) общее временное хранилище — пока оставлен
  про запас.
</comment></wordlist>

<def name="resolve-interface" ds=" d-interface-uri -- d-file-uri ">
  2DUP `: CONTAINS <unless> -5018 THROW </unless>
  2DUP `file:// STARTS-WITH <if> -5018 THROW </if>
  <rem> Only checks. The uri is not changed by default.</rem>
</def>

<def name="(load-sharedlex)" ds=" d-interface -- wid ">
  NEST-SCOPE
  GET-ORDER N>R ONLY  <!-- spf4 specific -->
  <!-- как вариант, здесь FORTH-WORDLIST можно отправлять на дно стека sharedlex,
  а стек ORDER оставлять пустым (при риске неверного перекрытия)
  FORTH-KERNEL CONTEXT ! -->
  deployed PUSH-CURRENT  <rem> Откладывание идет в базовое хранилище </rem>
  <wordlist name="{ 2DUP }">
    resolve-interface EMBODY
    GET-CURRENT
  </wordlist>
  DROP-CURRENT
  NR> SET-ORDER
  UNNEST-SCOPE
</def>
<def name="load-sharedlex" ds=" d-interface -- wid ">
  <xt-of name="(load-sharedlex)"/> WITHIN-FORTH-STORAGE-EXCLUSIVE
  <comment>
    Т.к. все разделяемые лексиконы загружаются в одно общее хранилище,
    и загружатся они могут в контексте различных дочерних потоков,
    здесь гарантируется, что они будут загружатся по очереди.

    При нарушении соглашений о реализации разделяемых лексиконов 
    (как то — создание новых потоков в процессе трансляции) есть шанс
    получить взаимную блокировку (deadlock).
  </comment>

  <comment>
    Если разрешить выделение памяти при загрузке лексикона, 
    то следует устанавливать общий хип процесса. Но, без
    дополнительных соглашений и процедур это без особой пользы.
  <rem>
  GetProcessHeap THREAD-HEAP <let><!-- spf4 specific -->
    <xt-of name="(load-sharedlex)"/> WITHIN-FORTH-STORAGE-EXCLUSIVE
  </let>
  </rem></comment>
</def>

<def name="fetch-sharedlex" ds=" d-interface -- wid ">
  deployed OBEY <unless> load-sharedlex </unless>
</def>


<f:g xmlns="http://forth.org.ru/ForthML/Rules/"
  xmlns:f="http://forth.org.ru/ForthML/"
>
<rule match="f:using">
  STATE? <f:if> ABORT </f:if>
  `href GetAttribute expanded-url
  fetch-sharedlex PUSH-SCOPE
</rule>
<rule match="f:forth">
  SCOPE-DEPTH >R
  <next-match> -5321 THROW </next-match>
  SCOPE-DEPTH R> - NDROP-SCOPE
</rule>
</f:g>
<comment>
  TODO: сделать вариант с созданием локального алиаса на загруженный словарь,
  чтобы далее использовать этот алиас как префикс (типа p::function), вместо
  того, чтобы добавлять этот словарь в контекст с риском неверного перекрытия
  при совпадении имен.
  Имя алиаса локально и задается в месте использования, поэтому непредвиденное
  совпадение этого имени исключено.
</comment>

</wordlist>

</forth>