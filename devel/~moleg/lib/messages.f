\ 25-08-2006 сообщения (см описание в конце) -------------------------------- 

        VOCABULARY msg 
                        ALSO msg DEFINITIONS 

        0 VALUE handle 

\ все настройки в этой секции ----------------------------------------------- 

\ по умолчанию все сообщения на экран 
:NONAME TYPE CR ;  ->VECT ~msg 
\ по умолчанию ожидание реакции на предупреждение 
:NONAME ."  press a key" KEY DROP ; ->VECT mwait 
\ имя текущего рабочего файла 
:NONAME S" .\bin\message." ; ->VECT file 

\ ---------------------------------------------------------------------- 

\ временно можно использовать буфер PAD 
: temp PAD 0x200 ; 

\ переместить указатель доступа к файлу 
: goto   ( d --> ) handle REPOSITION-FILE THROW ; 
: go-up  ( --> ) 0 0 goto ; 
: go-end ( --> ) handle FILE-SIZE THROW goto ; 

\ работа с записями 
: write ( asc # --> ) handle WRITE-LINE THROW ; 
: read  ( --> asc # flag ) temp OVER SWAP handle READ-LINE THROW ; 

\ всего строк в file 
: count ( --> n ) go-up 0 BEGIN read WHILE 2DROP 1+ REPEAT 2DROP ; 

\ вернуть сообщение из файла с номером n 
\ если сообщения с таким номером нет, вернуть строку с номером ошибки 
: nfind ( n --> asc # ) 
        go-up 
        BEGIN DUP WHILE 
              read WHILE 
              2DROP 
           1- 
         REPEAT <# #S S" message = " HOLDS #> EXIT 
        THEN DROP read DROP ; 

\ добавить новое сообщение в конец списка, 
\ вернуть порядковый номер сообщения 
: new ( asc # --> n ) count -ROT write ; 

\ инициализация начала работы 
: init  ( --> ) 
        file FILE-EXIST 
        IF file R/W OPEN-FILE 
         ELSE file R/W CREATE-FILE 
        THEN THROW TO handle ; 

\ найти аналогичную запись в файле 
: search ( asc # --> n true/asc # false ) 
         handle IF ELSE init THEN 

         go-up 0 >R 
         BEGIN read WHILE 
               2OVER COMPARE WHILE 
               R> 1+ >R 
          REPEAT 2DROP R> TRUE EXIT 
         THEN RDROP 2DROP FALSE ; 

\ вернуть номер сообщения 
: add ( asc # --> n / false ) search IF EXIT ELSE new THEN ; 

\ передать сообщение об ошибке обработчику ошибок 
: emsg   ER-U ! ER-A ! -2 THROW ; 

\ ---------------------------------------------------------------------- 

PREVIOUS DEFINITIONS 

ALSO msg 

: Error" [CHAR] " PARSE add 
         POSTPONE LITERAL  POSTPONE nfind POSTPONE emsg 
       ; IMMEDIATE 

: ?Error" 
         [COMPILE] IF 
         [CHAR] " PARSE add 
         POSTPONE LITERAL  POSTPONE nfind POSTPONE emsg 
         [COMPILE] THEN 
       ; IMMEDIATE 


\ просто вывести сообщение 
: Message" [CHAR] " PARSE add 
           POSTPONE LITERAL POSTPONE nfind 
           POSTPONE ~msg 
           ; IMMEDIATE 

\ вывести сообщение и подождать нажатия 
: Warning" [CHAR] " PARSE add 
           POSTPONE LITERAL  POSTPONE nfind 
           POSTPONE ~msg POSTPONE mwait 
           ; IMMEDIATE 

PREVIOUS 

\ ---------------------------------------------------------------------- 

\EOF тестовая секция ------------------------------------------------------- 

: mes ONLY FORTH ALSO msg DEFINITIONS ; 

: tst0 Message" message number one" ; 
: tst1 Warning" warning number two" ; 
: tst2 Error" error number three" ; 


\EOF ------------------------------------------------------------------- 
      Есть несколько подходов, применяемых для вывода сообщений на 
экран ( в том числе сообщений об ошибках). 

Можно писать ошибки в расшифрованном виде в тексте определений: 
      Abort" the error message" - это наглядно, но не всегда удобно, 
      так как одно и то же сообщение может быть вызвано целым рядом 
      определений - то есть налицо перерасход памяти; 

      можно создавать отдельные определения с именами ошибок: 
      : err007 Abort" ошибка номер семь" ; - и дальше использовать 
      ссылку на такое определение - перерасход имен, из текста сложно 
      понять что же все-таки за ошибка здесь приключиться должна; 

      можно создать список ошибок, каждый присвоить собственный 
      номер, и при возникновении ошибки искать ее в списке ( так 
      делает много фортов, включая СПФ ). Список ошибок можно хранить 
      в файле. Но недостатком такого подхода является необходимость 
      отслеживания ошибок по их номерам - то есть та же проблема, 
      что и во втором случае. 

      Я предлагаю поступить иначе. Я создаю список сообщений (в данном 
случае используется отдельный файл, но можно и в памяти его хранить. 
Сами сообщения об ошибках я пишу в тексте определения: Error" a message". 
Далее сообщение ищется в списке, если такого сообщения еще не было, то 
новое сообщение добавляется, ему присваивается номер, номер компилируется 
в текст сообщения. При необходимости вывести сообщение, оно ищется в 
списке по своему номеру, и выдается куда следует. Если, вдруг, список 
будет утерян, то куда надо будут выводиться номера ошибок, как это 
сделано в СПФ. 
      Использую медленную методику - каждый раз все сообщения 
перечитываются из файла заново. Но я рассчитываю, что сообщений будет 
не больше нескольких сотен, если будет нужда в обработке большего 
кол-ва сообщений, то можно будет создать уже реальную базу данных 
сообщений. Но это лишняя морока, по крайней мере мне пока ненужная.