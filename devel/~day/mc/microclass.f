( 13.05.2000 Dmitry Yakimov
  ver. 1.5.

  Эта библиотека была частично взята у ~1001bytes, доработана и 
  исправлена [!].  Спасибо тебе друг за
  светлые мысли. Фортерам [в моем лице] не хватает простого управления
  словарями. А остальное из ООП можно вручную. Разберем по порядку:
  В сравнении с ООП:
  1. Наследование данных - есть, если будете соблюдать правило:
     Использовать в классе структуры, размером указывать /ИМЯ_КЛАССА
     Пример:

     CLASS: Test
        0
          CELL FIELD x
          CELL FIELD y
        CONSTANT /Test
     ;CLASS


     WITH Test CHILD: Test1
        /Test
          CELL FIELD z
        CONSTANT /Test1
     ;CLASS
      
     \ Можно автоматически брать начальную длину структуры, но лучше
     \ дадим фортеру больше свободы  [простота залог понимания и надежности]
     \ Создание объекта:
     WITH Test1
       /Test1 OBJECT \ [ или /Test1 NEW]
       ...
     ENDWITH
     
     Причем, я думаю что константу /Test1 можно даже создавать автоматически,
     простым добавление слэша в начале. Хотя будем оптимально минимальны.
     Заметьте, что все является открытым с одной стороны, но ненавязчиво
     с другой. Это как раз для фортера. Наследование очень необходимо
     по той причине что фреймовое представление знаний оказывает нам услугу
     упрятывания массы деталей и делая массу вещей by default.
     
     [*] - FIELD - полный аналог -- только работает в контексте текущего
           объекта - использует self.
           
  2. Инкапсуляция
     Без инкапсуляции [сваливания в одну кучу данных и методов] это будет
     не ООП, а простой форт лексикон. Но нам не нужна зверская инкапсуляция
     с++ [ее очень ругал Броуди]. Нам нужна инкапсуляция с человеческим
     лицом, повернутым к нам и доброжелательным к тому же. Она есть.
     Она не запрещает нам в полной мере использовать лексикон и данные класса.
     АС скажет - а где приватные переменные как в Смоллтоке? А зачем они
     нужны - отвечу я. Если переменная нам нужна как контейнер или если угодно
     как некий переключатель состояния экземпляра и все операции с ней
     сводятся к простой записи/считыванию то зачем городить огород - может 
     просто разрешить к ним доступ? Ну а действительно private переменные
     нам никто и не запретит сделать, если захочется. Да, может быть трудность
     в использовании ООП библиотек другими программистами [у форта положение
     еще хуже], но если писать аккуратно, то все будет ОК.

  3. Полиморфизм
     Это когда каждый класс имеет свой метод с одинаковым именем, но они делают
     разные вещи в разных классах. Например у класса Point метод paint
     и у класса Rectangle метод paint.
     А оно нам надо? Надо. Но в такой форме как у нас - когда экземпляр
     НЕ  знает своего класса и вообще экземпляр состоит только из данных то
     будут возникать коллизии полиморфизма иногда [очень редко]. Это
     как раз случай, когда массиву разных экземпляров посылается сообщение
     с одним и тем же именем. Но МЫ - хозяевы :> - мы не то, что это
     предусмотрим, мы автоматически включим например в экзмепляр переменную
     селектор потому что мы пишем на форте и от форта никуда не отходили
     - слова да слова [фортовские].
  В общем, мне эта либа определенно нравится и она, можно сказать, плавлено
  войдет в мои программы.
  Можно и не пользоваться вышеприведенной схемой, а использовать только
  для управления словарями.
  Текст ниже. Комментарии больше либы в 2 раза. Вот вам и форт :]
)

HERE

USER-VALUE self

\ Определяем поля структур объектов
: FIELD
    CREATE OVER , +
    DOES> @ self +
;

: _exitm
\ Выход из метода
   R> TO self
;

: _in
\ Вход в метод
   R>
   self >R
   ['] _exitm >R
   >R TO self
;

\ Так определяется метод

: M: : POSTPONE _in ;

: DO-IT-DEF ( -- wid.compilation.prev )
  GET-CURRENT ( wid.compilation.prev )
  GET-ORDER 1+      \  ...widn n --
   LATEST-NAME NAME> XT>WID  \ достали wid
    SWAP SET-ORDER    \  widn wid n+1
  DEFINITIONS
;

: CLASS: ( "name" -- wid.compilation.prev ) VOCABULARY DO-IT-DEF ;

: ;CLASS  ( wid.compilation.prev -- ) PREVIOUS SET-CURRENT ;

: CHILD: ( "name" -- wid.compilation.prev )
          CONTEXT @ ( wid.parent ) PREVIOUS
          CLASS:  SWAP ( wid.compilation.prev wid.parent )
          GET-CURRENT CHAIN-WORDLIST \ подцепление списка слов родительского класса
;

: WITH ( "name.class" -- ) ALSO  PARSE-NAME EVAL-WORD ; IMMEDIATE
: ENDWITH PREVIOUS ; IMMEDIATE

: LOOK-FOR-INIT (  -- 0 | xt 1 | xt -1 )
   S" INIT" CONTEXT @ SEARCH-WORDLIST
;

: LOOK-FOR-DESTROY ( wid -- 0 | xt 1 | xt -1 )
   S" DESTROY" ROT SEARCH-WORDLIST
;

\ Создание объекта в словарном пространстве
: OBJECT  ( length  -- addr )
     HERE OVER ALLOT
      DUP ROT ERASE
       LOOK-FOR-INIT
       IF
         EXECUTE
       THEN
;

: (NEW) ( length  -- addr )
     DUP ALLOCATE THROW
      DUP ROT ERASE
;

\ Создание объекта в куче
: NEW ( -- )
  STATE @
  IF
    POSTPONE (NEW)
    LOOK-FOR-INIT
    IF
      COMPILE,
    THEN
  ELSE
    (NEW)
    LOOK-FOR-INIT
    IF
      EXECUTE
    THEN
  THEN
; IMMEDIATE

\ Наследование форт слов
: INHERIT ( -- )
   SMUDGE
   LATEST NAME>STRING DUP >R
   \ NB: LATEST-NAME игнорирует текущее определение
   PAD SWAP CMOVE
   HIDE PAD R>
   CONTEXT @ SEARCH-WORDLIST
   IF
     5 + \ пропустили _in - в этом отношении просто вызов форт слова
     COMPILE,
   THEN
; IMMEDIATE


HERE SWAP -
.( Length of microclass.f is ) . .( bytes ) CR
