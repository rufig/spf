
REQUIRE PLACE  ~mak\place.f 
REQUIRE [IF] ~MAK\CompIF1.f
REQUIRE DISASSEMBLER ~mak\lib\disasm.f 
\ REQUIRE DISASSEMBLER ~mak\mdisasm.f 

C" STREAM-FILE" FIND NIP
[IF]
: FROM_SOURCE-ID SOURCE-ID  STREAM-FILE ;
: TO_SOURCE-ID FILE>RSTREAM TO SOURCE-ID ;
[ELSE]
: FROM_SOURCE-ID SOURCE-ID ;
: TO_SOURCE-ID TO SOURCE-ID ;
[THEN]

: INST [ ALSO DISASSEMBLER ] INST 
       [ PREVIOUS ]  ;

C" -CELL" FIND NIP 0=
[IF] -1 CELLS CONSTANT -CELL
[THEN]

MODULE: LIST2

CREATE  FILE_NAME_L 120 ALLOT

CREATE   HERE-TAB  4000 CELLS ALLOT
HERE CELL-  CONSTANT HERE-TAB-MAX
VARIABLE HERE-TAB-CUR
HERE-TAB HERE-TAB-CUR !
VARIABLE S_STATE 

: HERE-TAB-CUR+
  HERE-TAB-CUR @  CELL+ HERE-TAB-MAX UMIN
  HERE-TAB-CUR
 !
\ [ .( XXXX) DIS-OPT KEY DROP ]
 ;
VECT oldpre
0 VALUE CURFILE@SAVE 
: HERE-TO-TAB
   CURFILE@SAVE 0= IF CURFILE @ TO CURFILE@SAVE THEN
   CURFILE@SAVE CURFILE @ =
   IF ( CR SOURCE TYPE )  DP @ \ CR ." c=" DUP H. CR 
 HERE-TAB-CUR @ ! HERE-TAB-CUR+
   THEN  oldpre ;


CREATE   SHERE-TAB  3700 CELLS ALLOT
HERE CELL-  CONSTANT SHERE-TAB-MAX
VARIABLE SHERE-TAB-CUR
SHERE-TAB SHERE-TAB-CUR !

: SHERE-TAB-CUR+
  SHERE-TAB-CUR @  CELL+ SHERE-TAB-MAX UMIN
  SHERE-TAB-CUR ! ;

: SHERE-TO-TAB
   CURFILE@SAVE CURFILE @ =
   IF DP @ \ CR ." H=" DUP H.
 SHERE-TAB-CUR @
\ DUP H.
 ! SHERE-TAB-CUR+ \ CR
   THEN ;

: SHERE-TO-TAB>
   CURFILE@SAVE CURFILE @ =
   IF DP @ 
\ CR ." D=" DUP H. CR 
1+ SHERE-TAB-CUR @
\ DUP H. 
! SHERE-TAB-CUR+
   THEN ;

80 VALUE DUMP_MAX 

: MDUMP ( addr u -- )
  DUP 0= IF 2DROP EXIT THEN
  BASE @ >R HEX
  BEGIN
    CR OVER BASE-ADDR - 4 .0 SPACE
    2DUP 0x10 MIN 
    2DUP 0 DO I 4 MOD 0= IF SPACE THEN
             DUP C@ 2 .0 SPACE 1+
           LOOP DROP
    DUP >R PTYPE
    R@ - SWAP R> + SWAP DUP 0=
  UNTIL  2DROP
  R> BASE ! CR
;

: .LIST ( ADDR  ADDR1 -- ADDR1' ) 
\  CR ." L=" .S CR

          S_STATE @
          IF
             SWAP
             BEGIN  2DUP U> 
             WHILE  INST CR
             REPEAT  NIP
          ELSE
            TUCK   
            OVER - DUP
            IF   DUP DUMP_MAX U>

                IF  >R DUMP_MAX DUMP 
                    CR DUP U.  R> DUMP_MAX - U. ." bytes"
                ELSE  MDUMP
                THEN CR
            ELSE 2DROP
            THEN
          THEN
\  CR ." .=" .S CR
\  ." >"  HERE-TAB-CUR @ CELL+ @ dup H.
\    0x16BFD13 = if \ f7_ed
\ HERE-TAB-CUR @  40 dump
\ then
 ;

EXPORT

: INCLUDED_L
   FIND-FULLNAME 2DUP FILE_NAME_L  PLACE  FILE_NAME_L COUNT + 0! 
   ['] <PRE> >BODY @ TO oldpre
   ['] HERE-TO-TAB TO <PRE>     0 TO  CURFILE@SAVE
     HERE-TAB  HERE-TAB-CUR !
    SHERE-TAB SHERE-TAB-CUR ! 

    INCLUDED_STD
   ['] oldpre >BODY @ TO <PRE>
 -1 SHERE-TAB-CUR @ !  SHERE-TAB-CUR+
    HERE-TO-TAB 
    HERE-TO-TAB       -CELL HERE-TAB-CUR +!
    HERE-TAB-CUR @ @  -CELL HERE-TAB-CUR +!
    BEGIN HERE-TAB-CUR @ HERE-TAB <>
    WHILE  HERE-TAB-CUR @ @ UMIN DUP HERE-TAB-CUR @ !
          -CELL HERE-TAB-CUR +!
    REPEAT DROP
    S_STATE 0!
    SHERE-TAB SHERE-TAB-CUR ! 

  FILE_NAME_L COUNT R/O   OPEN-FILE-SHARED THROW
  S" _L" FILE_NAME_L +PLACE  FILE_NAME_L COUNT + 0! 
  FILE_NAME_L COUNT W/O CREATE-FILE-SHARED THROW

  TIB >R >IN @ >R #TIB @ >R SOURCE-ID >R BLK @ >R CURSTR @ >R
  H-STDOUT >R  BASE @ >R HEX
  C/L 2 + ALLOCATE THROW TO TIB  BLK 0! 
  TO H-STDOUT
  TO_SOURCE-ID   
  CURSTR 0! HERE-TAB-CUR @ @
  BEGIN    REFILL
  WHILE
        SOURCE TYPE CR
        BEGIN  SHERE-TAB-CUR @
 @
 HERE-TAB-CUR @
 CELL+ @
  U<
        WHILE 
 SHERE-TAB-CUR @
 @
 .LIST
   SHERE-TAB-CUR+
                 S_STATE @ INVERT S_STATE !
        REPEAT  HERE-TAB-CUR+ 
 HERE-TAB-CUR @
 @
 .LIST
  REPEAT  DROP
  TIB FREE THROW
  FROM_SOURCE-ID
 CLOSE-FILE THROW ( ошибка закрытия файла )
  H-STDOUT CLOSE-FILE THROW ( ошибка закрытия файла )
  R> BASE ! R> TO H-STDOUT
  R> CURSTR ! R> BLK ! R> TO SOURCE-ID R> #TIB ! R> >IN ! R> TO TIB
;

: REQUIRED_L ( waddr wu laddr lu -- )
  2SWAP SFIND
  IF DROP 2DROP EXIT
  ELSE 2DROP INCLUDED_L THEN
;

: REQUIRE_L ( "word" "libpath" -- )
  PARSE-NAME PARSE-NAME 2DUP + 0 SWAP C!
  REQUIRED_L
;

WARNING @
\ WARNING 0! 

: :NONAME :NONAME  SHERE-TO-TAB ;
: : : SHERE-TO-TAB ;

: ;
 SHERE-TO-TAB>
 POSTPONE ;
; IMMEDIATE

: ENVIRONMENT? ( c-addr u -- false | i*x true ) \ 94
  CURFILE@SAVE >R  -1 TO CURFILE@SAVE
  ENVIRONMENT?
  R> TO CURFILE@SAVE ;

WARNING !

: SSSS
     HERE-TAB  HERE-TAB-CUR !
    SHERE-TAB SHERE-TAB-CUR ! 
;
;MODULE

\EOF

: (TranslateFlow_L) ( -- )
  BEGIN REFILL WHILE HERE-TO-TAB INTERPRET REPEAT
;

: TranslateFlow_L  ( -- )
  ['] (TranslateFlow_L) CATCH DUP IF
    SEEN-ERR? IF DUP SAVE-ERR THEN
  THEN THROW
;

: (INCLUDED_L) ( i*x a u -- j*x )
  R/O OPEN-FILE-SHARED THROW DUP >R
  BLK 0!
  ['] TranslateFlow_L RECEIVE-WITH ( ior )
  R> CLOSE-FILE SWAP THROW THROW
  \ Вначале обрабатываем ior от RECEIVE-WITH, а потом от CLOSE-FILE (!)
;

: INCLUDED_STD_L ( i*x c-addr u -- j*x )
  CURFILE @ >R
  2DUP HEAP-COPY CURFILE !
  ['] (INCLUDED_L) CATCH
  CURFILE @ FREE THROW
  R> CURFILE !
  THROW
;



: ENVIRONMENT? ( c-addr u -- false | i*x true ) \ 94
  1000 PAD 2OVER DROP GetEnvironmentVariableA
  DUP IF NIP NIP PAD SWAP TRUE EXIT THEN DROP

  SFIND IF EXECUTE TRUE EXIT THEN

  S" ENVIR.SPF" +ModuleDirName

  R/O OPEN-FILE-SHARED 0=
  IF  DUP >R  
      ['] (ENVIR?) RECEIVE-WITH  IF 0 THEN
      R> CLOSE-FILE THROW 
  ELSE 
    2DROP DROP 0 THEN
;
